use crate::*;
use ark_ec::PairingEngine;
use ark_ff::Field;
use ark_std::{end_timer, start_timer};
use std::collections::BTreeMap;
use ferveo_common::{ValidatorPublicKey, PublicKey};
use ark_ec::bn::TwistType::D;

/// The DKG context that holds all of the local state for participating in the DKG
pub struct PubliclyVerifiableDkg<E: PairingEngine> {
    pub params: Params,
    pub pvss_params: PubliclyVerifiableParams<E>,
    pub session_keypair: ferveo_common::Keypair<E>,
    pub validators: Vec<ferveo_common::Validator<E>>,
    pub vss: BTreeMap<u32, PubliclyVerifiableSS<E>>,
    pub domain: ark_poly::Radix2EvaluationDomain<E::Fr>,
    pub state: DkgState<E>,
    pub me: usize,
    pub validator_set: ValidatorSet,
}

#[derive(Clone, PartialEq, PartialOrd, Eq, Ord)]
/// Represents a tendermint validator
pub struct TendermintValidator {
    /// Total voting power in tendermint consensus
    pub power: u64,
    /// The established address of the validator
    pub address: String,
}

#[derive(Clone)]
/// The set of tendermint validators for a dkg instance
pub struct ValidatorSet {
    pub validators: Vec<TendermintValidator>,
}

impl ValidatorSet {
    /// Sorts the validators from highest to lowest. This ordering
    /// first considers staking weight and breaks ties on established
    /// address
    pub fn new(mut validators: Vec<TendermintValidator>) -> Self {
        // reverse the ordering here
        validators.sort_by(|a, b| b.cmp(a));
        Self {
            validators
        }
    }

    /// Get the total voting power of the validator set
    pub fn total_voting_power(&self) -> u64 {
        self.validators
            .iter()
            .map(|v| v.power)
            .sum()
    }
}


impl<E: PairingEngine> PubliclyVerifiableDkg<E> {
    /// Create a new DKG context to participate in the DKG
    /// Every identity in the DKG is linked to an ed25519 public key;
    /// `validator_set`: The set of validators and their respective voting powers
    ///                  *IMPORTANT: this set should be reverse sorted*
    /// `params` contains the parameters of the DKG such as number of shares
    /// `rng` is a cryptographic random number generator
    pub fn new<R: Rng>(
        validator_set: ValidatorSet,
        params: Params,
        me: TendermintValidator,
        rng: &mut R,
    ) -> Result<Self> {
        use ark_std::UniformRand;
        let domain = ark_poly::Radix2EvaluationDomain::<E::Fr>::new(
            params.total_weight as usize,
        )
        .ok_or_else(|| anyhow!("unable to construct domain"))?;

        // keep track of the owner of this instance in the validator set
        let me = validator_set
            .validators
            .binary_search_by(|probe| me.cmp(probe))
            .or(Err(anyhow!("could not find this validator in the provided validator set")))?;

        // partition out weight shares of validators based on their voting power
        let mut validators = partition_domain(
            &params,
            &validator_set
        )?;

        // We don't need to wait for announcements to store our own ephemeral public key
        let session_keypair =  ferveo_common::Keypair::<E>::new(rng);
        validators[me].key = ValidatorPublicKey::Announced(session_keypair.public());
        Ok(Self {
            session_keypair,
            params,
            pvss_params: PubliclyVerifiableParams::<E> {
                g: E::G1Projective::prime_subgroup_generator(),
                h: E::G2Projective::prime_subgroup_generator(),
            },
            vss: BTreeMap::new(),
            domain,
            state: DkgState::Init{accumulated_weight: 0},
            me,
            validators,
            validator_set,
        })
    }

    /// Create a new PVSS instance within this DKG session, contributing to the final key
    /// `rng` is a cryptographic random number generator
    /// Returns a PVSS dealing message to post on-chain
    pub fn share<R: Rng>(&mut self, rng: &mut R) -> Result<Message<E>> {
        use ark_std::UniformRand;
        print_time!("PVSS Sharing");

        let vss =
            PubliclyVerifiableSS::<E>::new(&E::Fr::rand(rng), &self, rng)?;

        let sharing = vss.clone();
        self.vss.insert(self.me as u32, vss);
        Ok(Message::Deal(sharing))
    }

    /// Aggregate all received PVSS messages into a single message, prepared to post on-chain
    pub fn aggregate(&mut self) -> Message<E> {
        Message::Aggregate(aggregate(self, &self.vss))
    }

    /// Returns the public key generated by the DKG
    pub fn final_key(&self) -> E::G1Affine {
        self.vss
            .iter()
            .map(|(_, vss)| vss.coeffs[0].into_projective())
            .sum::<E::G1Projective>()
            .into_affine()
    }


    /// Verify a DKG related message in a block proposal
    /// `sender` is the validator of the sender of the message
    /// `payload` is the content of the message
    pub fn verify_message(
        &mut self,
        sender: TendermintValidator,
        payload: Message<E>,
    ) -> Result<()> {
        match payload {
            Message::Deal(pvss) if matches!(self.state, DkgState::Init{..}) => {
                // TODO: If this is two slow, we can convert self.validators to
                // an address keyed hashmap after partitioning the weight shares
                // in the [`new`] method
                let sender = self.validator_set
                    .validators
                    .binary_search_by(|probe| sender.cmp(probe))
                    .or( Err(anyhow!("dkg received unknown dealer")))?;
                if self.vss.contains_key(&(sender as u32)) {
                    Err(anyhow!("Repeat dealer {}", sender))
                } else if !pvss.verify_optimistic() {
                    Err(anyhow!("Invalid PVSS transcript"))
                } else {
                    Ok(())
                }
            }
            Message::Aggregate(pvss) if matches!(self.state, DkgState::Shared) => {
                let minimum_weight = self.params.total_weight
                    - self.params.security_threshold;
                let verified_weight = pvss.verify_aggregation(&self)?;
                // we reject aggregations that fail to meet the security threshold
                if verified_weight < minimum_weight {
                    Err(
                        anyhow!("Aggregation failed because the verified weight was insufficient")
                    )
                } else {
                    Ok(())
                }
            }
            _ => Err(anyhow!("DKG state machine is not in correct state to verify this message"))
        }
    }

    /// After consensus has agreed to include a verified
    /// message on the blockchain, we apply the chains
    /// to the state machine
    pub fn apply_message(
        &mut self,
        sender: TendermintValidator,
        payload: Message<E>,
    ) -> Result<()> {
        match payload {
            Message::Deal(pvss) if matches!(self.state, DkgState::Init{..}) => {
                // Add the ephemeral public key and pvss transcript
                let sender = self.validator_set
                    .validators
                    .binary_search_by(|probe| sender.cmp(probe))
                    .or(Err(anyhow!("dkg received unknown dealer")))?;
                self.validators[sender].key
                    = ValidatorPublicKey::Announced(pvss.public_key);
                self.vss.insert(sender as u32, pvss);

                // we keep track of the amount of weight seen until the security
                // threshold is met. Then we may change the state of the DKG
                if let DkgState::Init{ref mut accumulated_weight} =  &mut self.state {
                    if *accumulated_weight
                        >= self.params.total_weight - self.params.security_threshold {
                      self.state = DkgState::Shared;
                    } else {
                        *accumulated_weight += self.validators[sender].weight;
                    }
                } else {
                    // protected by match guard
                    unreachable!()
                }
                Ok(())
            }
            Message::Aggregate(_) if matches!(self.state, DkgState::Shared) => {
                // change state and cache the final key
                self.state = DkgState::Success {final_key: self.final_key()};
                Ok(())
            }
            _ => Err(anyhow!("DKG state machine is not in correct state to apply this message"))
        }
    }
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(bound = "")]
pub enum Message<E: PairingEngine> {
    #[serde(with = "ferveo_common::ark_serde")]
    Deal(PubliclyVerifiableSS<E>),
    #[serde(with = "ferveo_common::ark_serde")]
    Aggregate(AggregatePubliclyVerifiableSS<E>),
}

#[derive(Debug, Clone)]
pub struct PubliclyVerifiableAnnouncement<E: PairingEngine> {
    pub session_key: ferveo_common::PublicKey<E>,
    pub stake: u64,
}

#[cfg(test)]
mod tests {

    use crate::dkg::PubliclyVerifiableDkg;
    use crate::*;
    use ark_bls12_381::G1Affine;
    use ark_ec::{bls12::Bls12, PairingEngine};
    use ark_std::{end_timer, start_timer};
    use group_threshold_cryptography::{
        decrypt_with_shared_secret, encrypt, setup, Ciphertext,
        DecryptionShare, PrivateDecryptionContext, PrivateKeyShare,
        PublicDecryptionContext, PublicKeyShares,
    };
    use itertools::izip;

    fn create_validator(vp: u64) -> TendermintValidator {
       TendermintValidator {
           power: vp,
           address: format!("validator_{}", i),
       }
    }

    #[test]
    pub fn test_pvdkg_tpke() {
        use ark_ec::{AffineCurve, ProjectiveCurve};
        let rng = &mut ark_std::test_rng();
        //use rand_old::SeedableRng;
        //let ed_rng = &mut rand_old::rngs::StdRng::from_seed([0u8; 32]);

        let params = Params {
            tau: 0u64,
            security_threshold: 300 / 3,
            total_weight: 300,
        };
        let validator_set = ValidatorSet {
            validators: (1..11u64).map(|vp|
                create_validator(vp)
            ).collect::<Vec<_>>(),
        };

        let validator_keys = (0..10)
            .map(|_| {
                ferveo_common::PublicKey::<ark_bls12_381::Bls12_381>::default()
            })
            .collect::<Vec<_>>();

        // for _ in 0..1 {
        let mut contexts = vec![];
        for me in 0..10 {
            contexts.push(
                PubliclyVerifiableDkg::<ark_bls12_381::Bls12_381>::new(
                    validator_set.clone(),
                    params.clone(),
                    create_validator(me),
                    rng,
                )
                .unwrap(),
            );
        }
        use std::collections::VecDeque;
        let mut messages = VecDeque::new();

        let mut dealt_weight = 0u32;
        for participant in contexts.iter_mut() {
            if dealt_weight < params.total_weight - params.security_threshold {
                let msg = participant.share(rng).unwrap();
                let msg: Message<ark_bls12_381::Bls12_381> = msg; //.verify().unwrap().1;
                messages.push_back((participant.me, msg));
                dealt_weight += participant.validators[participant.me].weight;
            }
        }
        for msg in messages.iter() {
            for node in contexts.iter_mut() {
                node.handle_message(msg.0 as u32, msg.1.clone()).unwrap();
            }
        }

        let tpke_pubkey = contexts[0].final_key();
        /*
        ///////////////////////////////////////// TPKE /////////////////////////////////////////
        let threshold = contexts[0].params.security_threshold as usize; //16 * 2 / 3;
        let shares_num = contexts[0].params.total_weight as usize; //16;
        let num_entities = contexts.len();
        let msg: &[u8] = "abc".as_bytes();

        // let (_, privkey, tpke_contexts) = setup::<ark_bls12_381::Bls12_381>(
        //     threshold,
        //     shares_num,
        //     num_entities,
        // );

        use ark_std::UniformRand;
        let rng = &mut ark_std::test_rng();

        let window_size = FixedBaseMSM::get_mul_window_size(100);
        let scalar_bits = <Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr::size_in_bits();
        let g = <Bls12<ark_bls12_381::Parameters> as PairingEngine>::G1Affine::prime_subgroup_generator();
        let h = <Bls12<ark_bls12_381::Parameters> as PairingEngine>::G2Affine::prime_subgroup_generator();

        let mut private_contexts = vec![];
        let mut public_contexts = vec![];

        // pub struct PubliclyVerifiableDKG<E>
        // {
        //     pub ed_key: ed25519::Keypair,
        // pub params: Params,
        //     pub pvss_params: PubliclyVerifiableParams<E>,
        // pub session_keypair: PubliclyVerifiableKeypair<E>,
        //     pub participants: Vec<PubliclyVerifiableParticipant<E>>,
        //     pub vss: BTreeMap<u32, PubliclyVerifiableSS<E>>,
        //     pub domain: ark_poly::Radix2EvaluationDomain<E::Fr>,
        //     pub state: DKGState<E>,
        //     pub me: usize,
        //     pub local_shares: Vec<E::G2Affine>,
        // }

        let fft_domain = ark_poly::Radix2EvaluationDomain::<
            <Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr,
        >::new(shares_num)
        .unwrap();
        let mut domain_points = Vec::with_capacity(shares_num);
        let mut point =
            <Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr::one();
        let mut domain_points_inv = Vec::with_capacity(shares_num);
        let mut point_inv =
            <Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr::one();

        for _ in 0..shares_num {
            domain_points.push(point);
            point *= fft_domain.group_gen;
            domain_points_inv.push(point_inv);
            point_inv *= fft_domain.group_gen_inv;
        }

        // let pubkey_shares: Vec<
        //     <Bls12<ark_bls12_381::Parameters> as PairingEngine>::G1Affine,
        // > = vec![];

        // for context in contexts {
        for (_, (context, domain, domain_inv, public)) in izip!(
            contexts,
            domain_points.chunks(shares_num / num_entities),
            domain_points_inv.chunks(shares_num / num_entities),
            pubkey_shares.chunks(shares_num / num_entities),
        )
        .enumerate()
        {
            let b =
                <Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr::rand(
                    rng,
                );
            let private_key_share = PrivateKeyShare::<ark_bls12_381::Bls12_381> {
                private_key_shares: context.local_shares,
            };
            let mut blinded_key_shares = private_key_share.blind(b.clone());
            blinded_key_shares.multiply_by_omega_inv(domain_inv);

            private_contexts.push(PrivateDecryptionContext::<ark_bls12_381::Bls12_381> {
                index: 0,//context.me,
                b,
                b_inv: b.inverse().unwrap(),
                private_key_share,
                public_decryption_contexts: vec![],
                g,
                g_inv: <Bls12<ark_bls12_381::Parameters> as PairingEngine>::G1Prepared::from(-g),
                h_inv: <Bls12<ark_bls12_381::Parameters> as PairingEngine>::G2Prepared::from(-h),
                scalar_bits,
                window_size,
            });
            let mut lagrange_n_0 = domain.iter().product::<<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr>();
            if domain.len() % 2 == 1 {
                lagrange_n_0 = -lagrange_n_0;
            }
            public_contexts.push(PublicDecryptionContext::<
                ark_bls12_381::Bls12_381,
            > {
                domain: domain.to_vec(),
                public_key_shares: PublicKeyShares::<ark_bls12_381::Bls12_381> {
                    public_key_shares: public.to_vec(),
                },
                blinded_key_shares,
                lagrange_n_0,
            });
        }
        for private in private_contexts.iter_mut() {
            private.public_decryption_contexts = public_contexts.clone();
        }

        let ciphertext =
            encrypt::<_, ark_bls12_381::Bls12_381>(msg, tpke_pubkey, rng);

        // create Decryption Shares
        let mut shares: Vec<DecryptionShare<ark_bls12_381::Bls12_381>> = vec![];
        for context in private_contexts.iter() {
            shares.push(context.create_share(&ciphertext));
        }

        let prepared_blinded_key_shares =
            private_contexts[0].prepare_combine(&shares);
        let s = private_contexts[0]
            .share_combine(&shares, &prepared_blinded_key_shares);

        let plaintext = decrypt_with_shared_secret(&ciphertext, &s);
        assert!(plaintext == msg)

        // }*/
    }
}
